{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Duplicate character in character class",
  "severity": "High",
  "comment": "Duplicate predefined character class 'w' inside character class",
  "detailsInfo": "Reports duplicate characters inside a RegExp character class. Duplicate characters are unnecessary and can be removed without changing the semantics of the regex.\n\n**Example:**\n\n\n      [aabc]\n\nAfter the quick-fix is applied:\n\n\n      [abc]\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/util/ConnectionUrlParser.java",
      "language": "RegExp",
      "line": 33,
      "offset": 32,
      "length": 3,
      "code": {
        "startLine": 31,
        "length": 3,
        "offset": 105,
        "surroundingCode": "  static final Pattern CONNECTION_STRING_PATTERN =\n      Pattern.compile(\n          \"(?<protocol>[\\\\w(\\\\-\\\\w)?\\\\+:%]+)\\\\s*\" // Driver protocol. \"word1:word2:...\" or \"word1-word2:word3:...\"\n              + \"(?://(?<hosts>[^/?#]*))?\\\\s*\" // Optional list of host(s) starting with // and\n              // follows by any char except \"/\", \"?\" or \"#\""
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "RegExpDuplicateCharacterInClass"
  },
  "hash": "a1005e6d764172e84ecf11db6bdc9187e15b64f6d65cb5cefe84659a23ef9085"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "'StringBuilder' can be replaced with 'String'",
  "severity": "High",
  "comment": "'StringBuilder urlBuilder' can be replaced with 'String'",
  "detailsInfo": "Reports usages of `StringBuffer`, `StringBuilder`, or `StringJoiner` which can be replaced with a single `String` concatenation.\n\nUsing `String` concatenation\nmakes the code shorter and simpler.\n\n\nThis inspection only reports when the suggested replacement does not result in significant\nperformance drawback on modern JVMs. In many cases, `String` concatenation may perform better.\n\n**Example:**\n\n\n      StringBuilder result = new StringBuilder();\n      result.append(\"i = \");\n      result.append(i);\n      result.append(\";\");\n      return result.toString();\n\nAfter the quick-fix is applied:\n\n\n      String result = \"i = \" + i + \";\";\n      return result;\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/DriverConnectionProvider.java",
      "language": "JAVA",
      "line": 64,
      "offset": 25,
      "length": 10,
      "code": {
        "startLine": 62,
        "length": 10,
        "offset": 98,
        "surroundingCode": "        ? PropertyDefinition.DATABASE_NAME.getString(props)\n        : \"\";\n    final StringBuilder urlBuilder = new StringBuilder();\n    urlBuilder.append(protocol).append(hostSpec.getUrl()).append(databaseName);\n"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "StringBufferReplaceableByString"
  },
  "hash": "e6e7a3955ea1a0fca6f031d90218f847ddf202d63a8652ac8490a10c3d50e435"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "'StringBuilder' can be replaced with 'String'",
  "severity": "High",
  "comment": "'StringBuilder msg' can be replaced with 'String'",
  "detailsInfo": "Reports usages of `StringBuffer`, `StringBuilder`, or `StringJoiner` which can be replaced with a single `String` concatenation.\n\nUsing `String` concatenation\nmakes the code shorter and simpler.\n\n\nThis inspection only reports when the suggested replacement does not result in significant\nperformance drawback on modern JVMs. In many cases, `String` concatenation may perform better.\n\n**Example:**\n\n\n      StringBuilder result = new StringBuilder();\n      result.append(\"i = \");\n      result.append(i);\n      result.append(\";\");\n      return result.toString();\n\nAfter the quick-fix is applied:\n\n\n      String result = \"i = \" + i + \";\";\n      return result;\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/plugin/failover/FailoverConnectionPlugin.java",
      "language": "JAVA",
      "line": 426,
      "offset": 23,
      "length": 3,
      "code": {
        "startLine": 424,
        "length": 3,
        "offset": 116,
        "surroundingCode": "    } catch (SQLException e) {\n      if (this.pluginService.getCurrentConnection() != null) {\n        StringBuilder msg =\n            new StringBuilder(\"Connection to \")\n                .append(isWriter(host) ? \"writer\" : \"reader\")"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "StringBufferReplaceableByString"
  },
  "hash": "2f0a540da39b71bcdaa0c34b148c25c5ef8c04da7ed52b8bd2053d25e098b55f"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Synchronization on 'this'",
  "severity": "High",
  "comment": "Lock operations on 'this' may have unforeseen side-effects",
  "detailsInfo": "Reports synchronization on `this` or `class` expressions. The reported constructs include `synchronized` blocks and calls to `wait()`, `notify()` or `notifyAll()`.\n\nThere are several reasons synchronization on `this` or `class` expressions may be a bad idea:\n\n1. it makes synchronization a part of the external interface of the class, which makes a future change to a different locking mechanism difficult,\n2. it becomes hard to track just who is locking on a given object,\n3. it makes a denial-of-service attack possible, either on purpose or it can happen easily by accident when subclassing.\n\nAs an alternative, consider synchronizing on a `private final` lock object, access to which can be completely controlled.\n\n**Example:**\n\n\n      public void print() {\n        synchronized(this) { // warning: Lock operations on 'this' may have unforeseen side-effects\n          System.out.println(\"synchronized\");\n        }\n      }\n      \n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/PluginServiceImpl.java",
      "language": "JAVA",
      "line": 259,
      "offset": 21,
      "length": 4,
      "code": {
        "startLine": 257,
        "length": 4,
        "offset": 111,
        "surroundingCode": "  public HostListProvider getHostListProvider() {\n    if (this.hostListProvider == null) {\n      synchronized (this) {\n        if (this.hostListProvider == null) {\n          this.hostListProvider = new ConnectionStringHostListProvider(this.props, this.originalUrl);"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "SynchronizeOnThis"
  },
  "hash": "c3b8ec05df0130d0ed3da21be89c8a93fd5deda607f3dc9af15a5a632668df43"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Unnecessary non-capturing group",
  "severity": "High",
  "comment": "Unnecessary non-capturing group '(?:s*/*(.*?)*/s*)'",
  "detailsInfo": "Reports unnecessary non-capturing groups, which have no influence on the match result.\n\n**Example:**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\nAfter the quick-fix is applied:\n\n\n      Everybody be cool, this is a robbery!\n\nNew in 2021.1",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/plugin/DefaultConnectionPlugin.java",
      "language": "RegExp",
      "line": 157,
      "offset": 44,
      "length": 3,
      "code": {
        "startLine": 155,
        "length": 3,
        "offset": 141,
        "surroundingCode": "  public boolean doesOpenTransaction(String statement) {\n    statement = statement.toUpperCase();\n    statement = statement.replaceAll(\"START(?:\\\\s*/\\\\*(.*?)\\\\*/\\\\s*)TRANSACTION\", \"START TRANSACTION\");\n    return statement.startsWith(\"BEGIN\") || statement.startsWith(\"START TRANSACTION\");\n  }"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "RegExpUnnecessaryNonCapturingGroup"
  },
  "hash": "cab28225dac10465b8b3fbca47fba0d9925225ac8efdc5bdb8a882b7e410499e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Passing 'null' argument to parameter annotated as @NotNull",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/PluginServiceImpl.java",
      "language": "JAVA",
      "line": 309,
      "offset": 58,
      "length": 4,
      "code": {
        "startLine": 307,
        "length": 4,
        "offset": 102,
        "surroundingCode": "      } else {\n        // host maybe changed\n        EnumSet<NodeChangeOptions> hostChanges = compare(null, entry.getValue(), null,\n            correspondingNewHost);\n        if (!hostChanges.isEmpty()) {"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "132925482c3707385276da918bc9c6dd25a0cbf0ad414c97854c697ff9940a5a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Passing 'null' argument to parameter annotated as @NotNull",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/PluginServiceImpl.java",
      "language": "JAVA",
      "line": 309,
      "offset": 82,
      "length": 4,
      "code": {
        "startLine": 307,
        "length": 4,
        "offset": 126,
        "surroundingCode": "      } else {\n        // host maybe changed\n        EnumSet<NodeChangeOptions> hostChanges = compare(null, entry.getValue(), null,\n            correspondingNewHost);\n        if (!hostChanges.isEmpty()) {"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "0963a864510c1a8d1628469a612500ac96a5591642eca7f89ff82a3be3ea4634"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'this.jdbcUrl' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/ds/AwsWrapperDataSource.java",
      "language": "JAVA",
      "line": 129,
      "offset": 11,
      "length": 12,
      "code": {
        "startLine": 127,
        "length": 12,
        "offset": 63,
        "surroundingCode": "      return new ConnectionWrapper(\n          props,\n          this.jdbcUrl,\n          new DataSourceConnectionProvider(\n              targetDataSource,"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "cd46f1cc4ef32b3563bcf7c6532aa72bd3a60e96174fa27e414879dca9c98e68"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'this.jdbcUrl' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/ds/AwsWrapperDataSource.java",
      "language": "JAVA",
      "line": 147,
      "offset": 30,
      "length": 12,
      "code": {
        "startLine": 145,
        "length": 12,
        "offset": 38,
        "surroundingCode": "      }\n\n      parsePropertiesFromUrl(this.jdbcUrl, props);\n      setCredentialProperties(props);\n      setDatabasePropertyFromUrl(props);"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "e26bd90bfcf88771419e45e2c595824164bd53d4f6708781db246d3afef39630"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Argument 'this.jdbcUrl' might be null",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/ds/AwsWrapperDataSource.java",
      "language": "JAVA",
      "line": 358,
      "offset": 69,
      "length": 12,
      "code": {
        "startLine": 356,
        "length": 12,
        "offset": 135,
        "surroundingCode": "\n  private void setCredentialPropertiesFromUrl(Properties props) {\n    final String userFromUrl = ConnectionUrlParser.parseUserFromUrl(this.jdbcUrl, this.userPropertyName);\n    if (isNullOrEmpty(this.user) && !isNullOrEmpty(userFromUrl)) {\n      PropertyDefinition.USER.set(props, userFromUrl);"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "7f0e0b00ac9e8b660adc99f70b16e02daee68ec12e54dcf081733f36d9d8e071"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.clusterId' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/hostlistprovider/AuroraHostListProvider.java",
      "language": "JAVA",
      "line": 336,
      "offset": 25,
      "length": 14,
      "code": {
        "startLine": 334,
        "length": 14,
        "offset": 56,
        "surroundingCode": "\n    synchronized (cacheLock) {\n      topologyCache.put(this.clusterId, clusterTopologyInfo);\n    }\n    return clusterTopologyInfo;"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "237e97d15d210f7ae85621eeb011c2fed4da1662dae45ef6db62dda34d2f29dc"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.hostListProvider' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/PluginServiceImpl.java",
      "language": "JAVA",
      "line": 260,
      "offset": 13,
      "length": 21,
      "code": {
        "startLine": 258,
        "length": 21,
        "offset": 81,
        "surroundingCode": "    if (this.hostListProvider == null) {\n      synchronized (this) {\n        if (this.hostListProvider == null) {\n          this.hostListProvider = new ConnectionStringHostListProvider(this.props, this.originalUrl);\n          this.currentHostSpec = this.getCurrentHostSpec();"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "55a70e87f0558049d2dccefb98814f2dd3ee5f4bc7d4811c207fed510218f9fb"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.hostListProvider' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/PluginServiceImpl.java",
      "language": "JAVA",
      "line": 261,
      "offset": 11,
      "length": 21,
      "code": {
        "startLine": 259,
        "length": 21,
        "offset": 83,
        "surroundingCode": "      synchronized (this) {\n        if (this.hostListProvider == null) {\n          this.hostListProvider = new ConnectionStringHostListProvider(this.props, this.originalUrl);\n          this.currentHostSpec = this.getCurrentHostSpec();\n        }"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "5df996feb1d4bc80487912b49c034c74cda88287093a4ba6fbe1c3d34e3a3b51"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.currentHostSpec' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/PluginServiceImpl.java",
      "language": "JAVA",
      "line": 262,
      "offset": 11,
      "length": 20,
      "code": {
        "startLine": 260,
        "length": 20,
        "offset": 157,
        "surroundingCode": "        if (this.hostListProvider == null) {\n          this.hostListProvider = new ConnectionStringHostListProvider(this.props, this.originalUrl);\n          this.currentHostSpec = this.getCurrentHostSpec();\n        }\n      }"
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "9e42fc16ff120c9b850f76e478fdf38ceb30c1dafc7ae6eb299b43c2ea840d7e"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Redundant character escape",
  "severity": "High",
  "comment": "Redundant character escape '+' in RegExp",
  "detailsInfo": "Reports redundant character escape sequences that can be replaced with unescaped characters preserving the meaning. Many escape sequences that are necessary outside of a character class are redundant inside square brackets `[]` of a character class.\n\n\nAlthough unescaped opening curly braces `{` outside of character classes are allowed in some dialects (JavaScript, Python, and so on),\nit can cause confusion and make the pattern less portable, because there are dialects that require escaping curly braces as characters.\nFor this reason the inspection does not report escaped opening curly braces.\n\n**Example:**\n\n\n      \\-\\;[\\.]\n\nAfter the quick-fix is applied:\n\n\n      -;[.]\n\n\nThe **Ignore escaped closing brackets '}' and '\\]'** option specifies whether to report `\\}` and `\\]` outside of a character class\nwhen they are allowed to be unescaped by the RegExp dialect.\n\nNew in 2017.3",
  "sources": [
    {
      "type": "file",
      "path": "wrapper/src/main/java/software/amazon/jdbc/util/ConnectionUrlParser.java",
      "language": "RegExp",
      "line": 33,
      "offset": 37,
      "length": 3,
      "code": {
        "startLine": 31,
        "length": 3,
        "offset": 110,
        "surroundingCode": "  static final Pattern CONNECTION_STRING_PATTERN =\n      Pattern.compile(\n          \"(?<protocol>[\\\\w(\\\\-\\\\w)?\\\\+:%]+)\\\\s*\" // Driver protocol. \"word1:word2:...\" or \"word1-word2:word3:...\"\n              + \"(?://(?<hosts>[^/?#]*))?\\\\s*\" // Optional list of host(s) starting with // and\n              // follows by any char except \"/\", \"?\" or \"#\""
      }
    }
  ],
  "attributes": {
    "module": "aws-advanced-jdbc-wrapper.aws-advanced-jdbc-wrapper.main",
    "inspectionName": "RegExpRedundantEscape"
  },
  "hash": "0bdf435354da8994c23bf3830fd11e009e085a0b006b7749092a9b46f6688f79"
}]}